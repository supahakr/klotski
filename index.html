<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klotski State-Space Graph Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #0a0a0a;
            color: #ffffff;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
        }

        .panel {
            pointer-events: auto;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(100, 100, 150, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            text-align: center;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(20, 20, 30, 0.95), rgba(20, 20, 30, 0));
        }

        #header h1 {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #4488ff;
            text-shadow: 0 0 10px rgba(68, 136, 255, 0.5);
        }

        #controls {
            position: absolute;
            top: 80px;
            left: 0;
            width: 280px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Custom scrollbar for controls */
        #controls::-webkit-scrollbar {
            width: 8px;
        }

        #controls::-webkit-scrollbar-track {
            background: rgba(20, 20, 30, 0.5);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb {
            background: rgba(68, 136, 255, 0.5);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb:hover {
            background: rgba(68, 136, 255, 0.7);
        }

        #stats {
            position: absolute;
            top: 80px;
            right: 0;
            width: 250px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Custom scrollbar for stats */
        #stats::-webkit-scrollbar {
            width: 8px;
        }

        #stats::-webkit-scrollbar-track {
            background: rgba(20, 20, 30, 0.5);
            border-radius: 4px;
        }

        #stats::-webkit-scrollbar-thumb {
            background: rgba(68, 136, 255, 0.5);
            border-radius: 4px;
        }

        #stats::-webkit-scrollbar-thumb:hover {
            background: rgba(68, 136, 255, 0.7);
        }

        #stateInfo {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 300px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 20px;
            pointer-events: none;
        }

        #loading.hidden {
            display: none;
        }

        .spinner {
            border: 4px solid rgba(68, 136, 255, 0.2);
            border-top: 4px solid #4488ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        button {
            background: linear-gradient(135deg, #4488ff, #2255cc);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #5599ff, #3366dd);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.compact {
            padding: 6px 12px;
            font-size: 12px;
            margin: 3px 0;
        }

        select {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid rgba(100, 100, 150, 0.3);
            color: white;
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            width: 100%;
            font-size: 14px;
        }

        .info-text {
            font-size: 14px;
            line-height: 1.6;
            color: #cccccc;
        }

        .legend {
            margin-top: 15px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #console {
            position: absolute;
            bottom: 220px;
            right: 0;
            width: 350px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        #boardState {
            min-width: 200px;
            max-width: 220px;
            cursor: pointer;
        }
        
        #boardState:hover {
            border-color: rgba(68, 136, 255, 0.6);
        }
        
        #boardState.hidden {
            display: none;
        }

        .console-line {
            padding: 2px 5px;
            border-bottom: 1px solid rgba(100, 100, 150, 0.1);
        }

        hr {
            border: none;
            border-top: 1px solid rgba(100, 100, 150, 0.3);
            margin: 10px 0;
        }

        .slider-container {
            margin: 8px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 4px;
            color: #aaaaaa;
        }

        .slider-value {
            color: #4488ff;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(40, 40, 60, 0.8);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4488ff, #2255cc);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4488ff, #2255cc);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: linear-gradient(135deg, #5599ff, #3366dd);
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: linear-gradient(135deg, #5599ff, #3366dd);
            transform: scale(1.1);
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
            padding: 8px;
            margin: 5px -15px;
            background: rgba(68, 136, 255, 0.1);
            border-radius: 4px;
            transition: background 0.2s;
        }

        .collapsible:hover {
            background: rgba(68, 136, 255, 0.2);
        }

        .collapsible::before {
            content: '▼ ';
            font-size: 10px;
            margin-right: 5px;
        }

        .collapsible.collapsed::before {
            content: '▶ ';
        }

        .collapsible-content {
            max-height: 1500px;
            overflow: visible;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.hidden {
            max-height: 0;
            overflow: hidden;
        }

        /* Board Editor */
        #boardEditor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #boardEditor.active {
            display: flex;
        }

        .editor-container {
            background: #1a1a2e;
            border: 2px solid #4488ff;
            border-radius: 10px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .editor-title {
            font-size: 24px;
            color: #4488ff;
            margin-bottom: 20px;
            text-align: center;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: repeat(4, 60px);
            grid-template-rows: repeat(5, 60px);
            gap: 2px;
            background: #0f0f1e;
            padding: 10px;
            border-radius: 5px;
            margin: 20px auto;
            width: fit-content;
            position: relative;
        }

        .grid-cell {
            width: 60px;
            height: 60px;
            background: #2a2a3e;
            border: 1px solid #3a3a4e;
            border-radius: 3px;
        }

        .grid-cell.occupied {
            background: #4a4a5e;
        }

        .block-piece {
            position: absolute;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            border: 2px solid rgba(0,0,0,0.3);
            user-select: none;
            touch-action: none;
        }

        .block-piece:active {
            cursor: grabbing;
        }

        .block-piece.dragging {
            opacity: 0.7;
            z-index: 100;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        .piece-palette {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .palette-piece {
            padding: 10px 15px;
            background: linear-gradient(135deg, #4488ff, #2255cc);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .palette-piece:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(68, 136, 255, 0.5);
        }

        .visual-piece {
            cursor: pointer;
            border: 2px solid rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .visual-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            filter: brightness(1.2);
        }

        .big-piece {
            width: 60px;
            height: 60px;
            background: #ff4444;
        }

        .vertical-piece {
            width: 30px;
            height: 60px;
            background: #4488ff;
        }

        .horizontal-piece {
            width: 60px;
            height: 30px;
            background: #44ff44;
        }

        .small-piece {
            width: 30px;
            height: 30px;
            background: #ffaa00;
        }

        .editor-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .editor-info {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin: 15px 0;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <!-- Board Editor Modal -->
    <div id="boardEditor">
        <div class="editor-container">
            <div class="editor-title">Custom Starting Board</div>
            <div class="editor-info">
                Set board size, then add pieces. Drag to reposition. Double-click to remove.
            </div>
            
            <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 15px; font-size: 12px; flex-wrap: wrap;">
                <label style="color: #aaa;">
                    Dimensions: 
                    <select id="boardDimension" style="margin-left: 5px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;" onchange="toggleDimension()">
                        <option value="2D">2D</option>
                        <option value="3D">3D</option>
                    </select>
                </label>
                <label style="color: #aaa;">
                    Width: 
                    <input type="number" id="boardWidth" min="2" max="15" value="4" style="width: 50px; margin-left: 5px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;">
                </label>
                <label style="color: #aaa;">
                    Height: 
                    <input type="number" id="boardHeight" min="2" max="15" value="5" style="width: 50px; margin-left: 5px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;">
                </label>
                <label style="color: #aaa;" id="depthLabel" class="hidden">
                    Depth: 
                    <input type="number" id="boardDepth" min="2" max="15" value="3" style="width: 50px; margin-left: 5px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;">
                </label>
                <button class="palette-piece" onclick="updateBoardSize()" style="padding: 4px 12px; margin: 0;">Apply Size</button>
            </div>
            
            <div class="piece-palette" style="margin-bottom: 20px;">
                <strong style="display: block; width: 100%; text-align: center; margin-bottom: 10px; color: #aaa;">Add Custom Piece:</strong>
                <div style="display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                    <label style="color: #aaa; font-size: 12px;">
                        Width: 
                        <input type="number" id="pieceWidth" min="1" max="4" value="1" style="width: 40px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;">
                    </label>
                    <label style="color: #aaa; font-size: 12px;">
                        Height: 
                        <input type="number" id="pieceHeight" min="1" max="5" value="1" style="width: 40px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;">
                    </label>
                    <label style="color: #aaa; font-size: 12px;" id="pieceDepthLabel" class="hidden">
                        Depth: 
                        <input type="number" id="pieceDepth" min="1" max="4" value="1" style="width: 40px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px;">
                    </label>
                    <button class="palette-piece" onclick="addCustomPiece()" style="padding: 6px 15px; margin: 0;">Add Piece</button>
                </div>
                <strong style="display: block; width: 100%; text-align: center; margin-bottom: 10px; color: #aaa; font-size: 11px;">Quick Add:</strong>
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <div class="visual-piece big-piece" onclick="addPieceToBoard(2, 2)" title="Big 2×2">★</div>
                    <div class="visual-piece vertical-piece" onclick="addPieceToBoard(1, 2)" title="Vertical 1×2"></div>
                    <div class="visual-piece horizontal-piece" onclick="addPieceToBoard(2, 1)" title="Horizontal 2×1"></div>
                    <div class="visual-piece small-piece" onclick="addPieceToBoard(1, 1)" title="Small 1×1"></div>
                    <div class="visual-piece" onclick="toggleDrawMode()" id="drawModeBtn" title="Draw Custom Shape" style="width: 60px; height: 60px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 32px;">✏</div>
                    <div class="visual-piece" onclick="toggleForbiddenMode()" id="forbiddenModeBtn" title="Mark Forbidden Cells" style="width: 60px; height: 60px; background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); font-size: 24px; display: flex; align-items: center; justify-content: center;">🚫</div>
                </div>
                <div id="drawModeInfo" style="display: none; text-align: center; margin-top: 10px; padding: 8px; background: #667eea; border-radius: 5px; color: white; font-size: 12px;">
                    <strong>Draw Mode Active:</strong> Click empty cells to draw shape. Click again to finish.<br>
                    <span style="font-size: 10px; opacity: 0.9;">Tip: Only the cells you click are solid. Empty space inside shapes won't block other pieces.</span>
                </div>
                <div id="forbiddenModeInfo" style="display: none; text-align: center; margin-top: 10px; padding: 8px; background: #ff6b6b; border-radius: 5px; color: white; font-size: 12px;">
                    <strong>Forbidden Mode Active:</strong> Click and drag over cells to mark them as forbidden. Pieces cannot move to forbidden cells.<br>
                    <span style="font-size: 10px; opacity: 0.9;">Forbidden cells will appear blacked out in the board state display.</span>
                </div>
            </div>
            
            <div id="layerControls" class="hidden" style="text-align: center; margin: 10px 0; padding: 10px; background: #1a1a2e; border-radius: 5px;">
                <label style="color: #aaa; margin-right: 10px;">Viewing Layer:</label>
                <button onclick="changeLayer(-1)" style="padding: 5px 12px; background: #4488ff; border: none; color: white; border-radius: 3px; cursor: pointer; margin: 0 5px;">◀ Back</button>
                <span id="currentLayer" style="color: white; font-weight: bold; margin: 0 10px;">Layer 0</span>
                <button onclick="changeLayer(1)" style="padding: 5px 12px; background: #4488ff; border: none; color: white; border-radius: 3px; cursor: pointer; margin: 0 5px;">Front ▶</button>
                <span style="color: #888; font-size: 11px; margin-left: 15px;">Pieces can move between layers</span>
            </div>
            
            <div class="editor-grid" id="editorGrid"></div>
            
            <div class="piece-palette" style="margin-top: 15px;">
                <button class="palette-piece" onclick="loadPreset('default')">Load Default</button>
                <button class="palette-piece" onclick="clearBoard()">Clear All</button>
            </div>
            
            <div class="editor-buttons">
                <button onclick="applyCustomBoard()">Generate Graph from This Board</button>
                <button onclick="closeEditor()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Shape Designer Modal -->
    <div id="shapeDesigner" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: #16213e; padding: 30px; border-radius: 10px; max-width: 600px; max-height: 90vh; overflow-y: auto;">
            <h2 style="color: white; margin: 0 0 20px 0; text-align: center;">Custom Shape Designer</h2>
            
            <div style="margin-bottom: 20px; text-align: center;">
                <label style="color: #aaa; margin-right: 20px;">
                    Grid Size: 
                    <input type="number" id="shapeGridSize" min="3" max="8" value="5" onchange="updateShapeGrid()" style="width: 50px; padding: 4px; background: #2a2a3e; border: 1px solid #4488ff; color: white; border-radius: 3px; margin-left: 5px;">
                </label>
                <button onclick="clearShapeGrid()" style="padding: 6px 15px; background: #ff4444; border: none; color: white; border-radius: 5px; cursor: pointer;">Clear</button>
            </div>
            
            <p style="color: #aaa; text-align: center; font-size: 13px; margin-bottom: 15px;">
                Click cells to toggle them. Shape must be connected.
            </p>
            
            <div id="shapeGrid" style="display: inline-grid; gap: 2px; margin: 0 auto; background: #0f1624; padding: 10px; border-radius: 5px;"></div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button onclick="addCustomShapeToBoard()" style="padding: 10px 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; margin-right: 10px;">Add to Board</button>
                <button onclick="closeShapeDesigner()" style="padding: 10px 30px; background: #555; border: none; color: white; border-radius: 5px; cursor: pointer; font-size: 14px;">Cancel</button>
            </div>
        </div>
    </div>
    
    <div id="ui">
        <div id="header">
            <h1>KLOTSKI STATE-SPACE GRAPH</h1>
        </div>

        <div id="controls" class="panel">
            <button id="generateBtn">Generate Graph</button>
            <button id="editBoardBtn">Edit Starting Board</button>
            <button id="resetCameraBtn">Reset Camera</button>
            <div style="margin-top: 10px; font-size: 12px;">
                <label>
                    <input type="checkbox" id="uniqueShapesCheckbox" style="margin-right: 5px;">
                    Treat same-shaped pieces as unique
                </label>
            </div>
            <div style="height: 10px;"></div>
            <button id="exportCudaBtn">Export Graph with Layout</button>
            <button id="importCudaBtn">Import Graph Layout</button>
            <div style="margin-top: 10px; font-size: 12px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="showNodesToggle" style="margin-right: 8px; cursor: pointer;">
                    <span>Show All Nodes</span>
                </label>
            </div>
            <hr>
            <div class="collapsible" id="paramsToggle">
                <strong>Force Parameters</strong>
            </div>
            <div class="collapsible-content" id="paramsContent">
                <div class="slider-container" style="margin-top: 10px;">
                    <div class="slider-label">
                        <span>Symmetry Strength</span>
                        <span class="slider-value" id="symmetryStrengthValue">0.5</span>
                    </div>
                    <input type="range" id="symmetryStrengthSlider" min="0.0" max="1.0" step="0.05" value="0.5">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        Enforces symmetries (0 = disabled)
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Repulsion Scale</span>
                        <span class="slider-value" id="scaleValue">1.0</span>
                    </div>
                    <input type="range" id="scaleSlider" min="0.1" max="10.0" step="0.1" value="1.0">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        Force strength multiplier
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Attraction Scale</span>
                        <span class="slider-value" id="attractionValue">0.1</span>
                    </div>
                    <input type="range" id="attractionSlider" min="0.0" max="3.0" step="0.1" value="0.1">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        6th-power edge attraction
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Speed Limit</span>
                        <span class="slider-value" id="speedValue">5.0</span>
                    </div>
                    <input type="range" id="speedSlider" min="1" max="50" step="0.5" value="5">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        Low = smooth, high = fast
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Dampening</span>
                        <span class="slider-value" id="dampeningValue">0.95</span>
                    </div>
                    <input type="range" id="dampeningSlider" min="0.5" max="0.999" step="0.001" value="0.95">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        High = smooth, low = chaotic
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Distance Exponent</span>
                        <span class="slider-value" id="exponentValue">1.5</span>
                    </div>
                    <input type="range" id="exponentSlider" min="0.5" max="4.0" step="0.1" value="1.5">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        Power of distance: r^n
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Force Constant</span>
                        <span class="slider-value" id="constantValue">2.0</span>
                    </div>
                    <input type="range" id="constantSlider" min="-2.0" max="10.0" step="0.1" value="2.0">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        Denominator offset
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Iterations</span>
                        <span class="slider-value" id="iterationsValue">1000</span>
                    </div>
                    <input type="range" id="iterationsSlider" min="50" max="2000" step="50" value="1000">
                    <div style="font-size: 10px; color: #888; margin-top: 2px;">
                        Higher = smoother (but slower)
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Initial Radius</span>
                        <span class="slider-value" id="radiusValue">200</span>
                    </div>
                    <input type="range" id="radiusSlider" min="50" max="300" step="10" value="200">
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Sample Size</span>
                        <span class="slider-value" id="sampleValue">150</span>
                    </div>
                    <input type="range" id="sampleSlider" min="20" max="200" step="10" value="150">
                </div>

                <button id="applyParamsBtn" class="compact">Apply Parameters</button>
                <button id="resetParamsBtn" class="compact">Reset to Default</button>
            </div>
            
            <hr>
            
            <div class="legend">
                <strong>Legend</strong>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4444;"></div>
                    <span>Initial State</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4488ff;"></div>
                    <span>Normal State</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff00;"></div>
                    <span>Winning State</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffff00;"></div>
                    <span>Selected</span>
                </div>
            </div>
        </div>

        <div id="stats" class="panel info-text">
            <strong>Graph Statistics</strong><br>
            States: 0<br>
            Transitions: 0<br>
            Avg. degree: 0
        </div>

        <div id="stateInfo" class="panel info-text">
            <strong>State Information</strong><br>
            Hover or click on nodes to view details
        </div>

        <div id="boardState" class="panel hidden" style="position: fixed; top: 80px; right: 15px; left: auto; width: auto; bottom: auto; z-index: 100;">
            <strong>Board State</strong> <span style="float: right; cursor: pointer; color: #ff4444;" onclick="closeBoardState()">✕</span><br>
            <div id="boardStateContent" style="margin-top: 10px; color: #888; font-size: 12px;">
                Click a node to view its board configuration
            </div>
        </div>

        <div id="console" class="panel">
            <strong>Console</strong>
            <div id="consoleOutput"></div>
        </div>

        <div id="loading" class="panel hidden">
            <div class="spinner"></div>
            <div id="loadingMessage">Generating state-space graph...</div>
            <div id="loadingProgress" style="margin-top: 10px; font-size: 14px;"></div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Game Logic and Visualization -->
    <script src="klotski.js"></script>
    <script src="visualization.js"></script>
    <script src="symmetry.js"></script>
    
    <script>
        // Console logging to UI
        const consoleOutput = document.getElementById('consoleOutput');
        const originalLog = console.log;
        console.log = function(...args) {
            originalLog.apply(console, args);
            const line = document.createElement('div');
            line.className = 'console-line';
            line.textContent = args.join(' ');
            consoleOutput.appendChild(line);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        };

        // Layout parameters (CUDA-style, tuned for better spread)
        let layoutParams = {
            repulsionScale: 1.0,         // Your optimal value
            attractionScale: 0.1,        // Your optimal value
            dampening: 0.95,             // Your optimal value
            speedLimit: 5.0,             // Speed limit for movement
            distanceExponent: 1.5,       // Your optimal value
            forceConstant: 2.0,          // Constant added to denominator
            iterations: 1000,            // More iterations for smoother layout
            initialRadius: 200,          // Larger initial distribution
            sampleSize: 150,             // More samples for better repulsion
            enforceSymmetry: true,       // Enforce graph symmetries (visual layout only)
            symmetryStrength: 0.5        // How strongly to enforce symmetries (0-1, 0=disabled)
        };

        // Custom starting state
        let customStartState = null;

        // Initialize
        let visualizer;
        let currentGraph;

        function init() {
            visualizer = new GraphVisualizer('container');
            visualizer.start();
        }

        function generateGraph() {
            console.log('🚀 generateGraph() called');
            const layoutType = 'force';  // Always use force-directed layout
            const loadingElement = document.getElementById('loading');
            const loadingMessage = document.getElementById('loadingMessage');
            
            // Check if user wants to treat same-shaped pieces as unique
            const treatShapesAsUnique = document.getElementById('uniqueShapesCheckbox').checked;
            console.log('✅ Checkbox checked:', treatShapesAsUnique);
            
            // Clear existing graph
            const hadPreviousGraph = currentGraph !== null;
            currentGraph = null;
            console.log('🗑️ Cleared previous graph:', hadPreviousGraph);
            
            loadingMessage.textContent = 'Generating state-space graph...';
            loadingElement.classList.remove('hidden');
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    console.log('=== Starting Graph Generation ===');
                    const initialState = customStartState || KlotskiState.createInitial();
                    console.log('Initial state created:', initialState);
                    const dimStr = initialState.is3D ? `${initialState.width}x${initialState.height}x${initialState.depth}` : `${initialState.width}x${initialState.height}`;
                    console.log('Board size:', dimStr, '| is3D:', initialState.is3D);
                    console.log('Blocks:', initialState.blocks.length);
                    console.log('Treat same-shaped pieces as unique:', treatShapesAsUnique);
                    
                    const graph = new StateSpaceGraph();
                    console.log('⏳ Calling graph.generate with treatShapesAsUnique:', treatShapesAsUnique);
                    graph.generate(initialState, 100000, treatShapesAsUnique);
                    console.log('✅ Graph generated:', graph.stateList.length, 'states');
                    
                    currentGraph = graph;
                    
                    console.log('=== Visualizing Graph ===');
                    visualizer.visualizeGraph(graph, layoutType);
                    console.log('✅ Visualization complete');
                    
                    console.log('=== Complete ===');
                } catch (error) {
                    console.error('Error generating graph:', error);
                    console.error('Stack trace:', error.stack);
                } finally {
                    loadingElement.classList.add('hidden');
                }
            }, 100);
        }

        function resetCamera() {
            visualizer.camera.position.set(150, 150, 250);
            visualizer.controls.target.set(0, 0, 0);
            visualizer.controls.update();
        }

        // Setup sliders
        function setupSliders() {
            const sliders = [
                { id: 'scale', param: 'repulsionScale' },
                { id: 'attraction', param: 'attractionScale' },
                { id: 'speed', param: 'speedLimit' },
                { id: 'dampening', param: 'dampening' },
                { id: 'exponent', param: 'distanceExponent' },
                { id: 'constant', param: 'forceConstant' },
                { id: 'iterations', param: 'iterations' },
                { id: 'radius', param: 'initialRadius' },
                { id: 'sample', param: 'sampleSize' },
                { id: 'symmetryStrength', param: 'symmetryStrength' }
            ];

            sliders.forEach(({ id, param }) => {
                const slider = document.getElementById(`${id}Slider`);
                const valueDisplay = document.getElementById(`${id}Value`);
                
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    layoutParams[param] = value;
                    valueDisplay.textContent = value;
                });
            });
        }

        function resetParameters() {
            layoutParams = {
                repulsionScale: 1.0,         // Your optimal value
                attractionScale: 0.1,        // Your optimal value
                dampening: 0.95,             // Your optimal value
                speedLimit: 5.0,
                distanceExponent: 1.5,       // Your optimal value
                forceConstant: 2.0,
                iterations: 1000,
                initialRadius: 200,
                sampleSize: 150,
                enforceSymmetry: true,
                symmetryStrength: 0.5
            };

            // Update sliders
            document.getElementById('scaleSlider').value = 1.0;
            document.getElementById('attractionSlider').value = 0.1;
            document.getElementById('speedSlider').value = 5;
            document.getElementById('dampeningSlider').value = 0.95;
            document.getElementById('exponentSlider').value = 1.5;
            document.getElementById('constantSlider').value = 2.0;
            document.getElementById('iterationsSlider').value = 1000;
            document.getElementById('radiusSlider').value = 200;
            document.getElementById('sampleSlider').value = 150;
            document.getElementById('symmetryStrengthSlider').value = 0.5;

            // Update displays
            document.getElementById('scaleValue').textContent = 1.0;
            document.getElementById('attractionValue').textContent = 0.1;
            document.getElementById('speedValue').textContent = 5.0;
            document.getElementById('dampeningValue').textContent = 0.95;
            document.getElementById('exponentValue').textContent = 1.5;
            document.getElementById('constantValue').textContent = 2.0;
            document.getElementById('iterationsValue').textContent = 1000;
            document.getElementById('radiusValue').textContent = 200;
            document.getElementById('sampleValue').textContent = 150;
            document.getElementById('symmetryStrengthValue').textContent = 0.5;
        }

        function applyParameters() {
            if (currentGraph) {
                console.log('Applying new parameters and regenerating layout...');
                console.log('Parameters:', layoutParams);
                visualizer.visualizeGraph(currentGraph, 'force');
            }
        }

        // Collapsible toggle
        document.getElementById('paramsToggle').addEventListener('click', function() {
            this.classList.toggle('collapsed');
            document.getElementById('paramsContent').classList.toggle('hidden');
        });

        // Board Editor
        let editorState = null;
        let draggedBlock = null;
        let dragOffset = {x: 0, y: 0};
        let nextBlockId = 0;
        let boardWidth = 4;
        let boardHeight = 5;
        let boardDepth = 1;  // Start with 2D
        let is3D = false;
        let currentViewLayer = 0; // Which Z-layer we're viewing in 3D mode
        
        function closeBoardState() {
            document.getElementById('boardState').classList.add('hidden');
        }

        function toggleDimension() {
            const dimension = document.getElementById('boardDimension').value;
            is3D = dimension === '3D';
            
            // Show/hide depth controls
            const depthLabel = document.getElementById('depthLabel');
            const pieceDepthLabel = document.getElementById('pieceDepthLabel');
            const layerControls = document.getElementById('layerControls');
            
            if (is3D) {
                depthLabel.classList.remove('hidden');
                pieceDepthLabel.classList.remove('hidden');
                layerControls.classList.remove('hidden');
                boardDepth = parseInt(document.getElementById('boardDepth').value) || 3;
                currentViewLayer = 0;
            } else {
                depthLabel.classList.add('hidden');
                pieceDepthLabel.classList.add('hidden');
                layerControls.classList.add('hidden');
                boardDepth = 1;
                currentViewLayer = 0;
            }
            
            updateBoardSize();
        }

        function changeLayer(delta) {
            currentViewLayer = Math.max(0, Math.min(boardDepth - 1, currentViewLayer + delta));
            document.getElementById('currentLayer').textContent = `Layer ${currentViewLayer}`;
            renderEditorBoard();
        }

        function moveBlockZ(block, delta) {
            const newZ = (block.z || 0) + delta;
            const blockDepth = block.depth || 1;
            
            // Check bounds
            if (newZ < 0 || newZ + blockDepth > boardDepth) {
                console.log('Cannot move block in Z: out of bounds');
                return;
            }
            
            // Check for collisions at new Z position
            if (canPlacePieceAt(block.x, block.y, newZ, block.width, block.height, blockDepth, block.id)) {
                block.z = newZ;
                // Update view to show the new layer if piece moved out of view
                if (newZ > currentViewLayer || newZ + blockDepth <= currentViewLayer) {
                    currentViewLayer = newZ;
                    document.getElementById('currentLayer').textContent = `Layer ${currentViewLayer}`;
                }
                renderEditorBoard();
                console.log(`Moved block to Z=${newZ}`);
            } else {
                console.log('Cannot move block in Z: collision detected');
            }
        }

        function openEditor() {
            document.getElementById('boardEditor').classList.add('active');
            // Start with blank board (just needs valid structure)
            if (customStartState) {
                editorState = customStartState.clone();
                boardWidth = editorState.width;
                boardHeight = editorState.height;
                boardDepth = editorState.depth || 1;
                is3D = editorState.is3D || false;
                
                // Update UI to match
                document.getElementById('boardDimension').value = is3D ? '3D' : '2D';
                if (is3D) {
                    document.getElementById('depthLabel').classList.remove('hidden');
                    document.getElementById('pieceDepthLabel').classList.remove('hidden');
                    document.getElementById('layerControls').classList.remove('hidden');
                }
                
                nextBlockId = editorState.blocks.length > 0 ? Math.max(...editorState.blocks.map(b => b.id)) + 1 : 0;
            } else {
                editorState = new KlotskiState([], boardWidth, boardHeight, boardDepth);
                nextBlockId = 0;
            }
            document.getElementById('boardWidth').value = boardWidth;
            document.getElementById('boardHeight').value = boardHeight;
            if (is3D) {
                document.getElementById('boardDepth').value = boardDepth;
            }
            renderEditorBoard();
        }
        
        function updateBoardSize() {
            const newWidth = parseInt(document.getElementById('boardWidth').value);
            const newHeight = parseInt(document.getElementById('boardHeight').value);
            const newDepth = is3D ? parseInt(document.getElementById('boardDepth').value) : 1;
            
            if (newWidth < 2 || newWidth > 20 || newHeight < 2 || newHeight > 20) {
                alert('Board width must be 2-20 and height must be 2-20');
                return;
            }
            
            if (is3D && (newDepth < 2 || newDepth > 20)) {
                alert('Board depth must be 2-20');
                return;
            }
            
            boardWidth = newWidth;
            boardHeight = newHeight;
            boardDepth = newDepth;
            
            // Remove pieces that are now out of bounds
            const validBlocks = editorState ? editorState.blocks.filter(block => {
                const blockZ = block.z || 0;
                
                if (block.cells) {
                    // Custom shape: check all cells
                    for (const [dx, dy, dz = 0] of block.cells) {
                        const cellX = block.x + dx;
                        const cellY = block.y + dy;
                        const cellZ = blockZ + dz;
                        if (cellX < 0 || cellY < 0 || cellZ < 0 ||
                            cellX >= boardWidth || cellY >= boardHeight || cellZ >= boardDepth) {
                            return false; // Cell is out of bounds
                        }
                    }
                    return true; // All cells are in bounds
                } else {
                    // Rectangle: check bounds
                    const blockDepth = block.depth || 1;
                    return block.x + block.width <= boardWidth && 
                           block.y + block.height <= boardHeight &&
                           blockZ + blockDepth <= boardDepth;
                }
            }) : [];
            
            // Create new state with new dimensions
            editorState = new KlotskiState(validBlocks, boardWidth, boardHeight, boardDepth);
            
            renderEditorBoard();
            const dimStr = is3D ? `${boardWidth}×${boardHeight}×${boardDepth}` : `${boardWidth}×${boardHeight}`;
            console.log(`Board resized to ${dimStr}`);
        }

        function closeEditor() {
            document.getElementById('boardEditor').classList.remove('active');
        }

        // Draw mode state
        let drawMode = false;
        let drawingCells = [];
        let isDraggingInDrawMode = false;
        let drawStartCell = null;
        let drawModeAction = 'add'; // 'add' or 'remove'
        
        // Forbidden mode state
        let forbiddenMode = false;
        let forbiddenCells = [];
        let isDraggingInForbiddenMode = false;
        let forbiddenStartCell = null;
        let forbiddenModeAction = 'add'; // 'add' or 'remove'
        
        function toggleDrawMode() {
            drawMode = !drawMode;
            const btn = document.getElementById('drawModeBtn');
            const info = document.getElementById('drawModeInfo');
            
            if (drawMode) {
                // Turn off forbidden mode if it's active
                if (forbiddenMode) {
                    forbiddenMode = false;
                    const forbiddenBtn = document.getElementById('forbiddenModeBtn');
                    const forbiddenInfo = document.getElementById('forbiddenModeInfo');
                    forbiddenBtn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)';
                    forbiddenBtn.textContent = '🚫';
                    forbiddenInfo.style.display = 'none';
                    // Clear any ongoing forbidden mode dragging
                    isDraggingInForbiddenMode = false;
                    forbiddenStartCell = null;
                }
                
                btn.style.background = '#ff4444'; // Red when active
                btn.textContent = '✓';
                info.style.display = 'block';
                drawingCells = [];
            } else {
                // Finish drawing
                if (drawingCells.length > 0) {
                    finishDrawing();
                }
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btn.textContent = '✏';
                info.style.display = 'none';
                drawingCells = [];
            }
            renderEditorBoard();
        }
        
        function toggleForbiddenMode() {
            forbiddenMode = !forbiddenMode;
            const btn = document.getElementById('forbiddenModeBtn');
            const info = document.getElementById('forbiddenModeInfo');
            
            if (forbiddenMode) {
                // Turn off draw mode if it's active
                if (drawMode) {
                    drawMode = false;
                    const drawBtn = document.getElementById('drawModeBtn');
                    const drawInfo = document.getElementById('drawModeInfo');
                    drawBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    drawBtn.textContent = '✏';
                    drawInfo.style.display = 'none';
                    // Finish any ongoing drawing
                    if (drawingCells.length > 0) {
                        finishDrawing();
                    }
                    drawingCells = [];
                }
                
                btn.style.background = '#ff4444'; // Red when active
                btn.textContent = '✓';
                info.style.display = 'block';
            } else {
                // Clear any ongoing forbidden mode dragging
                isDraggingInForbiddenMode = false;
                forbiddenStartCell = null;
                
                btn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)';
                btn.textContent = '🚫';
                info.style.display = 'none';
            }
            renderEditorBoard();
        }
        
        // Add global mouse up handler for draw mode
        document.addEventListener('mouseup', () => {
            if (isDraggingInDrawMode) {
                isDraggingInDrawMode = false;
                drawStartCell = null;
            }
            if (isDraggingInForbiddenMode) {
                isDraggingInForbiddenMode = false;
                forbiddenStartCell = null;
            }
        });
        
        function finishDrawing() {
            if (drawingCells.length === 0) {
                alert('Please select at least one cell!');
                return;
            }
            
            // Check connectivity
            if (!isShapeConnected(drawingCells)) {
                alert('Shape must be connected! All cells should be adjacent.');
                drawingCells = [];
                renderEditorBoard();
                return;
            }
            
            // Normalize to origin
            const minX = Math.min(...drawingCells.map(c => c.x));
            const minY = Math.min(...drawingCells.map(c => c.y));
            const minZ = Math.min(...drawingCells.map(c => c.z));
            
            const cells = drawingCells.map(c => [c.x - minX, c.y - minY, c.z - minZ]);
            const originX = Math.min(...drawingCells.map(c => c.x));
            const originY = Math.min(...drawingCells.map(c => c.y));
            const originZ = Math.min(...drawingCells.map(c => c.z));
            
            // Create the piece
            const piece = {
                id: nextBlockId++,
                x: originX,
                y: originY,
                z: originZ,
                cells: cells,
                name: `custom-${nextBlockId}`
            };
            
            editorState.blocks.push(piece);
            console.log('✓ Added custom shape:', piece);
            console.log(`  Position: (${originX}, ${originY}, ${originZ})`);
            console.log(`  Cells (relative):`, cells);
        }
        
        function renderEditorBoard() {
            const grid = document.getElementById('editorGrid');
            grid.innerHTML = '';
            
            // Update grid template
            grid.style.gridTemplateColumns = `repeat(${boardWidth}, 60px)`;
            grid.style.gridTemplateRows = `repeat(${boardHeight}, 60px)`;

            // Create grid cells
            for (let y = 0; y < boardHeight; y++) {
                for (let x = 0; x < boardWidth; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Add click and drag handlers for draw mode
                    if (drawMode) {
                        cell.style.cursor = 'crosshair';
                        
                        // Mouse down - start dragging
                        cell.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            isDraggingInDrawMode = true;
                            drawStartCell = {x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y)};
                            
                            const cellX = parseInt(cell.dataset.x);
                            const cellY = parseInt(cell.dataset.y);
                            const cellZ = is3D ? currentViewLayer : 0;
                            
                            // Check if cell is occupied
                            if (isPieceAt(cellX, cellY, cellZ)) {
                                isDraggingInDrawMode = false;
                                drawStartCell = null;
                                return; // Can't draw on occupied cells
                            }
                            
                            // Toggle cell in drawing and set action mode
                            const idx = drawingCells.findIndex(c => c.x === cellX && c.y === cellY && c.z === cellZ);
                            if (idx >= 0) {
                                drawingCells.splice(idx, 1);
                                drawModeAction = 'remove'; // Dragging will remove cells
                            } else {
                                drawingCells.push({x: cellX, y: cellY, z: cellZ});
                                drawModeAction = 'add'; // Dragging will add cells
                            }
                            renderEditorBoard();
                        });
                        
                        // Mouse enter - continue dragging
                        cell.addEventListener('mouseenter', (e) => {
                            if (!isDraggingInDrawMode) return;
                            
                            const cellX = parseInt(cell.dataset.x);
                            const cellY = parseInt(cell.dataset.y);
                            const cellZ = is3D ? currentViewLayer : 0;
                            
                            // Check if cell is occupied
                            if (isPieceAt(cellX, cellY, cellZ)) {
                                return; // Can't draw on occupied cells
                            }
                            
                            // Add or remove based on action mode
                            const idx = drawingCells.findIndex(c => c.x === cellX && c.y === cellY && c.z === cellZ);
                            if (drawModeAction === 'add' && idx < 0) {
                                drawingCells.push({x: cellX, y: cellY, z: cellZ});
                                renderEditorBoard();
                            } else if (drawModeAction === 'remove' && idx >= 0) {
                                drawingCells.splice(idx, 1);
                                renderEditorBoard();
                            }
                        });
                    }
                    
                    // Add click and drag handlers for forbidden mode
                    if (forbiddenMode) {
                        cell.style.cursor = 'crosshair';
                        
                        // Mouse down - start dragging
                        cell.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            isDraggingInForbiddenMode = true;
                            forbiddenStartCell = {x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y)};
                            
                            const cellX = parseInt(cell.dataset.x);
                            const cellY = parseInt(cell.dataset.y);
                            const cellZ = is3D ? currentViewLayer : 0;
                            
                            // Check if cell is occupied by a piece
                            if (isPieceAt(cellX, cellY, cellZ)) {
                                isDraggingInForbiddenMode = false;
                                forbiddenStartCell = null;
                                return; // Can't mark occupied cells as forbidden
                            }
                            
                            // Toggle cell in forbidden and set action mode
                            const idx = forbiddenCells.findIndex(c => c.x === cellX && c.y === cellY && c.z === cellZ);
                            if (idx >= 0) {
                                forbiddenCells.splice(idx, 1);
                                forbiddenModeAction = 'remove'; // Dragging will remove cells
                            } else {
                                forbiddenCells.push({x: cellX, y: cellY, z: cellZ});
                                forbiddenModeAction = 'add'; // Dragging will add cells
                            }
                            renderEditorBoard();
                        });
                        
                        // Mouse enter - continue dragging
                        cell.addEventListener('mouseenter', (e) => {
                            if (!isDraggingInForbiddenMode) return;
                            
                            const cellX = parseInt(cell.dataset.x);
                            const cellY = parseInt(cell.dataset.y);
                            const cellZ = is3D ? currentViewLayer : 0;
                            
                            // Check if cell is occupied by a piece
                            if (isPieceAt(cellX, cellY, cellZ)) {
                                return; // Can't mark occupied cells as forbidden
                            }
                            
                            // Add or remove based on action mode
                            const idx = forbiddenCells.findIndex(c => c.x === cellX && c.y === cellY && c.z === cellZ);
                            if (forbiddenModeAction === 'add' && idx < 0) {
                                forbiddenCells.push({x: cellX, y: cellY, z: cellZ});
                                renderEditorBoard();
                            } else if (forbiddenModeAction === 'remove' && idx >= 0) {
                                forbiddenCells.splice(idx, 1);
                                renderEditorBoard();
                            }
                        });
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Draw preview cells for drawing mode
            if (drawMode) {
                for (const {x, y, z} of drawingCells) {
                    if (!is3D || z === currentViewLayer) {
                        const previewDiv = document.createElement('div');
                        previewDiv.style.cssText = `
                            position: absolute;
                            left: ${10 + x * 62}px;
                            top: ${10 + y * 62}px;
                            width: 60px;
                            height: 60px;
                            background: rgba(102, 126, 234, 0.6);
                            border: 2px solid #667eea;
                            border-radius: 4px;
                            z-index: 5;
                            pointer-events: none;
                        `;
                        grid.appendChild(previewDiv);
                    }
                }
            }
            
            // Draw forbidden cells
            for (const {x, y, z} of forbiddenCells) {
                if (!is3D || z === currentViewLayer) {
                    const forbiddenDiv = document.createElement('div');
                    forbiddenDiv.style.cssText = `
                        position: absolute;
                        left: ${10 + x * 62}px;
                        top: ${10 + y * 62}px;
                        width: 60px;
                        height: 60px;
                        background: rgba(0, 0, 0, 0.8);
                        border: 2px solid #ff4444;
                        border-radius: 4px;
                        z-index: 6;
                        pointer-events: none;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 20px;
                        color: #ff4444;
                    `;
                    forbiddenDiv.textContent = '🚫';
                    grid.appendChild(forbiddenDiv);
                }
            }
            
            // Render blocks
            editorState.blocks.forEach(block => {
                const blockZ = block.z || 0;
                const blockDepth = block.depth || 1;
                
                // Get color based on shape signature
                const color = getBlockColor(block);
                
                // Handle custom shapes differently
                if (block.cells) {
                    // For custom shapes, check if any cells are in this layer
                    const cellsInLayer = block.cells.filter(([dx, dy, dz = 0]) => {
                        return !is3D || (blockZ + dz) === currentViewLayer;
                    });
                    
                    if (cellsInLayer.length === 0) return; // No cells in this layer
                    
                    // Create a container div that looks like one solid piece
                    const containerDiv = document.createElement('div');
                    containerDiv.className = 'block-piece';
                    containerDiv.dataset.blockId = block.id;
                    containerDiv.style.position = 'absolute';
                    containerDiv.style.zIndex = '10'
                    
                    const minX = Math.min(...cellsInLayer.map(c => c[0]));
                    const maxX = Math.max(...cellsInLayer.map(c => c[0]));
                    const minY = Math.min(...cellsInLayer.map(c => c[1]));
                    const maxY = Math.max(...cellsInLayer.map(c => c[1]));
                    
                    containerDiv.style.left = (10 + (block.x + minX) * 62) + 'px';
                    containerDiv.style.top = (10 + (block.y + minY) * 62) + 'px';
                    containerDiv.style.width = ((maxX - minX + 1) * 62 - 2) + 'px';
                    containerDiv.style.height = ((maxY - minY + 1) * 62 - 2) + 'px';
                    
                    // Container always passes through to not block grid cells
                    containerDiv.style.pointerEvents = 'none';
                    containerDiv.style.cursor = '';
                    
                    // Create SVG to draw the complex shape
                    const svgNS = 'http://www.w3.org/2000/svg';
                    const svg = document.createElementNS(svgNS, 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    svg.style.display = 'block';
                    
                    // In draw mode, disable all pointer events
                    if (drawMode) {
                        svg.style.pointerEvents = 'none';
                    } else {
                        svg.style.pointerEvents = 'auto'; // SVG captures events for delegation
                    }
                    
                    // Draw each cell as a rectangle in the SVG
                    // Match exact grid cell size (60x60) and position
                    cellsInLayer.forEach(([dx, dy]) => {
                        const rect = document.createElementNS(svgNS, 'rect');
                        rect.setAttribute('x', (dx - minX) * 62);
                        rect.setAttribute('y', (dy - minY) * 62);
                        rect.setAttribute('width', 60);
                        rect.setAttribute('height', 60);
                        rect.setAttribute('fill', color);
                        rect.setAttribute('stroke', 'rgba(0, 0, 0, 0.3)');
                        rect.setAttribute('stroke-width', '2');
                        rect.setAttribute('rx', '4');
                        if (drawMode) {
                            rect.style.pointerEvents = 'none'; // Explicitly disable in draw mode
                        } else {
                            rect.style.cursor = 'grab';
                            rect.style.pointerEvents = 'auto';
                        }
                        svg.appendChild(rect);
                    });
                    
                    containerDiv.appendChild(svg);
                    
                    // Add shadow and styling
                    containerDiv.style.filter = 'drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2))';
                    containerDiv.style.userSelect = 'none';
                    
                    // Track double-click manually to avoid drag interference
                    let lastClickTime = 0;
                    const handleClick = (e) => {
                        const now = Date.now();
                        if (now - lastClickTime < 300) {
                            // Double click detected
                            e.stopPropagation();
                            e.preventDefault();
                            console.log('Double-click detected on custom shape, deleting...');
                            editorState.blocks = editorState.blocks.filter(b => b.id !== block.id);
                            renderEditorBoard();
                        }
                        lastClickTime = now;
                    };
                    
                    // Only add interaction handlers if not in draw mode
                    if (!drawMode) {
                        svg.addEventListener('click', handleClick);
                        
                        // Make draggable - use event delegation on SVG
                        svg.addEventListener('mousedown', (e) => {
                            // Only start drag if clicking on a rect (filled cell)
                            if (e.target.tagName === 'rect') {
                                startDrag(e, block);
                            }
                        });
                        svg.addEventListener('touchstart', (e) => {
                            // Check touch target
                            const touch = e.touches[0];
                            const target = document.elementFromPoint(touch.clientX, touch.clientY);
                            if (target && target.tagName === 'rect') {
                                startDrag(touch, block);
                            }
                        });
                    }
                    
                    grid.appendChild(containerDiv);
                    return; // Skip standard rendering
                }
                
                // Standard rectangular pieces
                // In 3D mode, only show blocks that occupy the current viewing layer
                if (is3D && (blockZ > currentViewLayer || blockZ + blockDepth <= currentViewLayer)) {
                    return; // Skip this block, it's not in current layer
                }
                
                const blockDiv = document.createElement('div');
                blockDiv.className = 'block-piece';
                blockDiv.dataset.blockId = block.id;
                
                blockDiv.style.background = color;
                
                // In draw mode, disable pointer events on rectangular pieces too
                if (drawMode) {
                    blockDiv.style.pointerEvents = 'none';
                }
                
                // Add visual indicator for 3D blocks spanning multiple layers
                if (is3D && blockDepth > 1) {
                    blockDiv.style.border = '3px solid #ffaa00'; // Orange border for multi-layer pieces
                }
                blockDiv.style.width = (block.width * 60 + (block.width - 1) * 2) + 'px';
                blockDiv.style.height = (block.height * 60 + (block.height - 1) * 2) + 'px';
                
                // Position absolutely within grid
                blockDiv.style.position = 'absolute';
                blockDiv.style.left = (10 + block.x * 62) + 'px';
                blockDiv.style.top = (10 + block.y * 62) + 'px';
                blockDiv.style.zIndex = '10';
                
                // Show piece info
                if (block.width === 2 && block.height === 2) {
                    blockDiv.textContent = '★';
                } else if (is3D) {
                    // Show Z-position and depth for 3D pieces
                    if (blockDepth > 1) {
                        blockDiv.textContent = `Z${blockZ}-${blockZ + blockDepth - 1}`;
                    } else {
                        blockDiv.textContent = `Z${blockZ}`;
                    }
                    blockDiv.style.fontSize = '10px';
                    blockDiv.style.color = 'white';
                } else {
                    blockDiv.textContent = '';
                }
                
                // Make draggable (X, Y) - only if not in draw mode
                if (!drawMode) {
                    blockDiv.addEventListener('mousedown', (e) => startDrag(e, block));
                    blockDiv.addEventListener('touchstart', (e) => startDrag(e.touches[0], block));
                }
                
                // Add Z-axis movement controls for 3D
                if (is3D) {
                    const zControls = document.createElement('div');
                    zControls.style.cssText = 'position: absolute; top: 2px; right: 2px; display: flex; gap: 2px; z-index: 20;';
                    zControls.onclick = (e) => e.stopPropagation();
                    
                    const backBtn = document.createElement('button');
                    backBtn.textContent = '◀';
                    backBtn.style.cssText = 'width: 16px; height: 16px; font-size: 8px; padding: 0; background: #4488ff; color: white; border: none; border-radius: 2px; cursor: pointer;';
                    backBtn.title = 'Move to back layer (Z-)';
                    backBtn.onclick = (e) => { e.stopPropagation(); moveBlockZ(block, -1); };
                    
                    const frontBtn = document.createElement('button');
                    frontBtn.textContent = '▶';
                    frontBtn.style.cssText = 'width: 16px; height: 16px; font-size: 8px; padding: 0; background: #4488ff; color: white; border: none; border-radius: 2px; cursor: pointer;';
                    frontBtn.title = 'Move to front layer (Z+)';
                    frontBtn.onclick = (e) => { e.stopPropagation(); moveBlockZ(block, 1); };
                    
                    zControls.appendChild(backBtn);
                    zControls.appendChild(frontBtn);
                    blockDiv.appendChild(zControls);
                }
                
                // Double click to remove - only if not in draw mode
                if (!drawMode) {
                    blockDiv.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        editorState.blocks = editorState.blocks.filter(b => b.id !== block.id);
                        renderEditorBoard();
                    });
                }

                grid.appendChild(blockDiv);
            });
        }
        
        function startDrag(e, block) {
            e.preventDefault();
            draggedBlock = block;
            
            const gridRect = document.getElementById('editorGrid').getBoundingClientRect();
            
            // For custom shapes, calculate offset from block origin, not from clicked element
            if (block.cells) {
                // Get the actual block position on the grid
                const blockScreenX = gridRect.left + 10 + block.x * 62;
                const blockScreenY = gridRect.top + 10 + block.y * 62;
                
                dragOffset.x = e.clientX - blockScreenX;
                dragOffset.y = e.clientY - blockScreenY;
            } else {
                // For rectangles, use the element's position
                const rect = e.target.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
            }
            
            e.target.classList.add('dragging');
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', onTouchDrag);
            document.addEventListener('touchend', stopDrag);
        }
        
        function onDrag(e) {
            if (!draggedBlock) return;
            e.preventDefault();
            updateDragPosition(e.clientX, e.clientY);
        }
        
        function onTouchDrag(e) {
            if (!draggedBlock) return;
            e.preventDefault();
            updateDragPosition(e.touches[0].clientX, e.touches[0].clientY);
        }
        
        function updateDragPosition(clientX, clientY) {
            const gridRect = document.getElementById('editorGrid').getBoundingClientRect();
            
            // Calculate grid position
            const relX = clientX - gridRect.left - dragOffset.x - 10;
            const relY = clientY - gridRect.top - dragOffset.y - 10;
            
            const gridX = Math.round(relX / 62);
            const gridY = Math.round(relY / 62);
            
            // Check if this is a custom shape or rectangle
            const dragZ = draggedBlock.z || 0;
            const dragDepth = draggedBlock.depth || 1;
            let newX, newY, canPlace;
            
            if (draggedBlock.cells) {
                // Custom shape
                newX = gridX;
                newY = gridY;
                canPlace = canPlacePieceAt(newX, newY, dragZ, draggedBlock.cells, null, dragDepth, draggedBlock.id);
                
                // Debug logging for custom shapes
                if (!canPlace && (Math.abs(newX - draggedBlock.x) <= 1 && Math.abs(newY - draggedBlock.y) <= 1)) {
                    console.log(`❌ Cannot move custom shape to (${newX}, ${newY}):`);
                    console.log('  Current position:', draggedBlock.x, draggedBlock.y);
                    console.log('  Checking cells:', draggedBlock.cells);
                    console.log('  Collision details:');
                    draggedBlock.cells.forEach(([dx, dy, dz = 0]) => {
                        const checkX = newX + dx;
                        const checkY = newY + dy;
                        const checkZ = dragZ + dz;
                        const occupied = isPieceAt(checkX, checkY, checkZ, draggedBlock.id);
                        const outOfBounds = checkX < 0 || checkY < 0 || checkZ < 0 || 
                            checkX >= boardWidth || checkY >= boardHeight || checkZ >= boardDepth;
                        if (occupied || outOfBounds) {
                            console.log(`    ⚠ Cell (${dx},${dy},${dz}) → (${checkX},${checkY},${checkZ}): ${occupied ? 'BLOCKED by another piece' : 'OUT OF BOUNDS'}`);
                        }
                    });
                    console.log('  💡 Tip: In Klotski, pieces slide into empty spaces. They cannot push other pieces.');
                }
            } else {
                // Rectangle
                newX = Math.max(0, Math.min(gridX, boardWidth - draggedBlock.width));
                newY = Math.max(0, Math.min(gridY, boardHeight - draggedBlock.height));
                canPlace = canPlacePieceAt(newX, newY, dragZ, draggedBlock.width, draggedBlock.height, dragDepth, draggedBlock.id);
            }
            
            if (canPlace) {
                draggedBlock.x = newX;
                draggedBlock.y = newY;
                renderEditorBoard();
            }
        }
        
        function stopDrag() {
            if (draggedBlock) {
                const draggingEl = document.querySelector('.dragging');
                if (draggingEl) draggingEl.classList.remove('dragging');
                draggedBlock = null;
            }
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', onTouchDrag);
            document.removeEventListener('touchend', stopDrag);
        }
        
        function canPlacePieceAt(x, y, z, widthOrCells, height, depth, excludeId) {
            // Support both rectangular pieces and custom shapes
            // widthOrCells can be either width (number) or cells (array)
            const isCustomShape = Array.isArray(widthOrCells);
            
            // For 2D, z and depth are ignored (z=0, depth=1)
            z = z || 0;
            depth = depth || 1;
            
            if (isCustomShape) {
                // Check each cell of the custom shape
                const cells = widthOrCells;
                for (const [dx, dy, dz = 0] of cells) {
                    const cellX = x + dx;
                    const cellY = y + dy;
                    const cellZ = z + dz;
                    
                    // Check bounds
                    if (cellX < 0 || cellY < 0 || cellZ < 0 ||
                        cellX >= boardWidth || cellY >= boardHeight || cellZ >= boardDepth) {
                        return false;
                    }
                    
                    // Check collision with other blocks (cell-by-cell)
                    if (isPieceAt(cellX, cellY, cellZ, excludeId)) {
                        return false;
                    }
                    
                    // Check if cell is forbidden
                    if (isCellForbidden(cellX, cellY, cellZ)) {
                        return false;
                    }
                }
                return true;
            } else {
                // Rectangle check - check each cell individually
                const width = widthOrCells;
                
                if (x < 0 || y < 0 || z < 0 || 
                    x + width > boardWidth || y + height > boardHeight || z + depth > boardDepth) {
                    return false;
                }
                
                // Check each cell of the rectangle for collision
                for (let dz = 0; dz < depth; dz++) {
                    for (let dy = 0; dy < height; dy++) {
                        for (let dx = 0; dx < width; dx++) {
                            if (isPieceAt(x + dx, y + dy, z + dz, excludeId)) {
                                return false;
                            }
                            
                            // Check if cell is forbidden
                            if (isCellForbidden(x + dx, y + dy, z + dz)) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
        }
        
        // Helper function to check if any cell of a custom shape occupies a given position
        function doesCustomShapeOccupyCell(block, targetX, targetY, targetZ) {
            if (!block.cells) return false;
            const blockZ = block.z || 0;
            for (const [dx, dy, dz = 0] of block.cells) {
                if (block.x + dx === targetX && 
                    block.y + dy === targetY && 
                    blockZ + dz === targetZ) {
                    return true;
                }
            }
            return false;
        }
        
        function isPieceAt(x, y, z, excludeId = -1) {
            z = z || 0; // Default Z for 2D
            for (const block of editorState.blocks) {
                if (block.id === excludeId) continue;
                
                if (block.cells) {
                    // Custom shape: check all cells
                    for (const [dx, dy, dz = 0] of block.cells) {
                        const blockZ = block.z || 0;
                        if (block.x + dx === x && block.y + dy === y && (blockZ + dz) === z) {
                            return true;
                        }
                    }
                } else {
                    // Rectangle
                    const blockZ = block.z || 0;
                    const blockDepth = block.depth || 1;
                    
                    if (x >= block.x && x < block.x + block.width &&
                        y >= block.y && y < block.y + block.height &&
                        z >= blockZ && z < blockZ + blockDepth) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function isCellForbidden(x, y, z) {
            z = z || 0; // Default Z for 2D
            return forbiddenCells.some(cell => 
                cell.x === x && cell.y === y && cell.z === z
            );
        }
        
        // Get normalized shape signature for consistent coloring
        function getShapeSignature(block) {
            if (block.cells) {
                // Custom shape: normalize to origin and sort
                const cells = block.cells.map(([dx, dy, dz = 0]) => [dx, dy, dz]);
                
                // Find min coordinates
                const minX = Math.min(...cells.map(c => c[0]));
                const minY = Math.min(...cells.map(c => c[1]));
                const minZ = Math.min(...cells.map(c => c[2]));
                
                // Normalize to origin
                const normalized = cells.map(([x, y, z]) => [x - minX, y - minY, z - minZ]);
                
                // Sort
                normalized.sort((a, b) => {
                    if (a[2] !== b[2]) return a[2] - b[2];
                    if (a[1] !== b[1]) return a[1] - b[1];
                    return a[0] - b[0];
                });
                
                return `custom:${normalized.map(c => c.join(',')).join(';')}`;
            } else {
                // Rectangle: use width x height x depth
                const depth = block.depth || 1;
                return is3D ? `rect:${block.width}x${block.height}x${depth}` : `rect:${block.width}x${block.height}`;
            }
        }
        
        // Get color for a block based on its shape
        function getBlockColor(block) {
            const signature = getShapeSignature(block);
            
            // Fixed colors for standard rectangles (default Klotski colors)
            // Match both 2D (rect:WxH) and 3D (rect:WxHxD) signatures
            const standardColors = {
                'rect:2x2': '#ff4444',  // Red for 2x2 (big piece)
                'rect:2x2x1': '#ff4444',
                'rect:1x2': '#4488ff',  // Blue for 1x2 (vertical)
                'rect:1x2x1': '#4488ff',
                'rect:2x1': '#44ff44',  // Green for 2x1 (horizontal)
                'rect:2x1x1': '#44ff44',
                'rect:1x1': '#ffaa00',  // Orange for 1x1 (small)
                'rect:1x1x1': '#ffaa00'
            };
            
            if (standardColors[signature]) {
                return standardColors[signature];
            }
            
            // For custom shapes, generate color based on shape signature
            // Same-shaped pieces will have the same color
            let hash = 0;
            for (let i = 0; i < signature.length; i++) {
                hash = ((hash << 5) - hash) + signature.charCodeAt(i);
                hash = hash & hash;
            }
            
            // Use golden angle for good distribution across full spectrum
            const baseHue = (Math.abs(hash) * 137.5) % 360;
            
            // Narrow avoid ranges around standard piece colors only:
            // Red: 0±15, Orange: 35±10, Green: 120±15, Blue: 225±15
            const avoidRanges = [
                {center: 0, width: 15},     // Red
                {center: 35, width: 10},    // Orange  
                {center: 120, width: 15},   // Green
                {center: 225, width: 15}    // Blue
            ];
            
            let adjustedHue = baseHue;
            
            // Check if we're too close to any standard color
            for (const {center, width} of avoidRanges) {
                const distance = Math.min(
                    Math.abs(adjustedHue - center),
                    360 - Math.abs(adjustedHue - center)  // Wrap around
                );
                
                if (distance < width) {
                    // Shift away from this color
                    // Push to midpoint between this color and the next
                    if (center === 0) adjustedHue = 300; // Between blue and red → magenta
                    else if (center === 35) adjustedHue = 65; // Between orange and green → yellow-green
                    else if (center === 120) adjustedHue = 170; // Between green and blue → cyan
                    else if (center === 225) adjustedHue = 270; // Between blue and red → purple
                    break;
                }
            }
            
            return `hsl(${adjustedHue}, 70%, 55%)`;
        }

        function clearBoard() {
            editorState = new KlotskiState([], boardWidth, boardHeight, boardDepth);
            nextBlockId = 0;
            forbiddenCells = [];
            renderEditorBoard();
        }

        function loadPreset(preset) {
            if (preset === 'default') {
                editorState = KlotskiState.createInitial();
                boardWidth = editorState.width;
                boardHeight = editorState.height;
                document.getElementById('boardWidth').value = boardWidth;
                document.getElementById('boardHeight').value = boardHeight;
                nextBlockId = 10;
            }
            renderEditorBoard();
        }
        
        function findEmptySpot(width, height, depth = 1) {
            // Try to find first available spot
            for (let z = 0; z <= boardDepth - depth; z++) {
                for (let y = 0; y <= boardHeight - height; y++) {
                    for (let x = 0; x <= boardWidth - width; x++) {
                        if (canPlacePieceAt(x, y, z, width, height, depth, -1)) {
                            return is3D ? {x, y, z} : {x, y};
                        }
                    }
                }
            }
            return null;
        }
        
        function addCustomPiece() {
            const width = parseInt(document.getElementById('pieceWidth').value);
            const height = parseInt(document.getElementById('pieceHeight').value);
            const depth = is3D ? parseInt(document.getElementById('pieceDepth').value) : 1;
            
            if (width < 1 || height < 1 || width > boardWidth || height > boardHeight) {
                alert(`Piece dimensions must be 1-${boardWidth} wide and 1-${boardHeight} tall for this board`);
                return;
            }
            
            if (is3D && (depth < 1 || depth > boardDepth)) {
                alert(`Piece depth must be 1-${boardDepth} for this board`);
                return;
            }
            
            addPieceToBoard(width, height, depth);
        }

        function addPieceToBoard(width, height, depth = 1) {
            console.log(`Trying to add piece ${width}×${height}×${depth}...`);
            console.log(`  Current pieces on board: ${editorState.blocks.length}`);
            
            // In 3D mode, try to find spot starting from current viewing layer
            const spot = is3D ? findEmptySpotFromLayer(width, height, depth, currentViewLayer) : findEmptySpot(width, height, depth);
            if (spot) {
                const piece = {
                    id: nextBlockId++,
                    x: spot.x,
                    y: spot.y,
                    width: width,
                    height: height,
                    name: is3D ? `${width}x${height}x${depth}` : `${width}x${height}`
                };
                if (is3D) {
                    piece.z = spot.z || 0;
                    piece.depth = depth;
                }
                editorState.blocks.push(piece);
                renderEditorBoard();
                const dimStr = is3D ? `${width}×${height}×${depth} at (${spot.x}, ${spot.y}, ${spot.z})` : `${width}×${height} at (${spot.x}, ${spot.y})`;
                console.log(`✓ Added ${dimStr}`);
            } else {
                console.error('✗ No space available for this piece!');
                console.log('  Board occupancy:');
                editorState.blocks.forEach(b => {
                    if (b.cells) {
                        console.log(`    Custom shape at (${b.x}, ${b.y}, ${b.z || 0}):`, b.cells);
                    } else {
                        console.log(`    Rectangle ${b.width}×${b.height} at (${b.x}, ${b.y}, ${b.z || 0})`);
                    }
                });
                alert('No space available for this piece! Try removing some pieces first.');
            }
        }

        function findEmptySpotFromLayer(width, height, depth, startLayer) {
            // Try current layer first, then expand search
            for (let zOffset = 0; zOffset < boardDepth; zOffset++) {
                const z = (startLayer + zOffset) % boardDepth;
                if (z + depth > boardDepth) continue;
                
                for (let y = 0; y <= boardHeight - height; y++) {
                    for (let x = 0; x <= boardWidth - width; x++) {
                        if (canPlacePieceAt(x, y, z, width, height, depth, -1)) {
                            return {x, y, z};
                        }
                    }
                }
            }
            return null;
        }

        function applyCustomBoard() {
            if (editorState.blocks.length === 0) {
                alert('Please add at least one piece to the board!');
                return;
            }
            // Create properly dimensioned state (including depth for 3D)
            customStartState = new KlotskiState(editorState.blocks, boardWidth, boardHeight, boardDepth, forbiddenCells);
            closeEditor();
            const dimStr = is3D ? `${boardWidth}×${boardHeight}×${boardDepth}` : `${boardWidth}×${boardHeight}`;
            console.log(`Custom board set! Size: ${dimStr}, Blocks: ${editorState.blocks.length}, is3D: ${customStartState.is3D}`);
            console.log('Custom start state:', customStartState);
            generateGraph();
        }

        // Custom Shape Designer
        let shapeGridCells = [];
        let shapeGridSize = 5;

        function openShapeDesigner() {
            document.getElementById('shapeDesigner').style.display = 'flex';
            shapeGridSize = parseInt(document.getElementById('shapeGridSize').value) || 5;
            updateShapeGrid();
        }

        function closeShapeDesigner() {
            document.getElementById('shapeDesigner').style.display = 'none';
        }

        function updateShapeGrid() {
            shapeGridSize = parseInt(document.getElementById('shapeGridSize').value) || 5;
            const grid = document.getElementById('shapeGrid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${shapeGridSize}, 40px)`;
            
            shapeGridCells = [];
            for (let y = 0; y < shapeGridSize; y++) {
                for (let x = 0; x < shapeGridSize; x++) {
                    const cell = document.createElement('div');
                    cell.style.width = '40px';
                    cell.style.height = '40px';
                    cell.style.background = '#1a1a2e';
                    cell.style.border = '1px solid #4488ff';
                    cell.style.cursor = 'pointer';
                    cell.style.transition = 'all 0.2s';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.dataset.active = 'false';
                    
                    cell.addEventListener('click', () => {
                        const isActive = cell.dataset.active === 'true';
                        cell.dataset.active = isActive ? 'false' : 'true';
                        cell.style.background = isActive ? '#1a1a2e' : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                        cell.style.transform = isActive ? 'scale(1)' : 'scale(0.95)';
                    });
                    
                    cell.addEventListener('mouseenter', () => {
                        if (cell.dataset.active === 'false') {
                            cell.style.background = '#2a2a3e';
                        }
                    });
                    
                    cell.addEventListener('mouseleave', () => {
                        if (cell.dataset.active === 'false') {
                            cell.style.background = '#1a1a2e';
                        }
                    });
                    
                    grid.appendChild(cell);
                    shapeGridCells.push(cell);
                }
            }
        }

        function clearShapeGrid() {
            shapeGridCells.forEach(cell => {
                cell.dataset.active = 'false';
                cell.style.background = '#1a1a2e';
                cell.style.transform = 'scale(1)';
            });
        }

        function addCustomShapeToBoard() {
            // Collect active cells
            const activeCells = shapeGridCells.filter(cell => cell.dataset.active === 'true').map(cell => ({
                x: parseInt(cell.dataset.x),
                y: parseInt(cell.dataset.y)
            }));
            
            if (activeCells.length === 0) {
                alert('Please select at least one cell!');
                return;
            }
            
            // Check if shape is connected using BFS
            if (!isShapeConnected(activeCells)) {
                alert('Shape must be connected! All cells should be adjacent to each other.');
                return;
            }
            
            // Normalize shape: shift to origin (0, 0)
            const minX = Math.min(...activeCells.map(c => c.x));
            const minY = Math.min(...activeCells.map(c => c.y));
            const normalizedCells = activeCells.map(c => [c.x - minX, c.y - minY, 0]); // [dx, dy, dz]
            
            // Find a spot on the board for this shape
            const spot = findEmptySpotForShape(normalizedCells);
            if (!spot) {
                alert('No space on the board for this shape!');
                return;
            }
            
            // Add the piece
            const piece = {
                id: nextBlockId++,
                x: spot.x,
                y: spot.y,
                z: spot.z || 0,
                cells: normalizedCells,
                name: `custom-${nextBlockId}`
            };
            
            editorState.blocks.push(piece);
            renderEditorBoard();
            closeShapeDesigner();
            console.log('Added custom shape piece:', piece);
        }

        function isShapeConnected(cells) {
            if (cells.length === 0) return false;
            if (cells.length === 1) return true;
            
            // BFS to check connectivity (including Z-direction)
            const visited = new Set();
            const queue = [cells[0]];
            const cellZ = cells[0].z !== undefined ? cells[0].z : 0;
            visited.add(`${cells[0].x},${cells[0].y},${cellZ}`);
            
            while (queue.length > 0) {
                const current = queue.shift();
                const currentZ = current.z !== undefined ? current.z : 0;
                
                // Check all 6 neighbors (including Z-direction for 3D)
                const neighbors = [
                    {x: current.x + 1, y: current.y, z: currentZ},
                    {x: current.x - 1, y: current.y, z: currentZ},
                    {x: current.x, y: current.y + 1, z: currentZ},
                    {x: current.x, y: current.y - 1, z: currentZ},
                    {x: current.x, y: current.y, z: currentZ + 1},
                    {x: current.x, y: current.y, z: currentZ - 1}
                ];
                
                for (const neighbor of neighbors) {
                    const nZ = neighbor.z !== undefined ? neighbor.z : 0;
                    const key = `${neighbor.x},${neighbor.y},${nZ}`;
                    if (!visited.has(key) && cells.some(c => {
                        const cZ = c.z !== undefined ? c.z : 0;
                        return c.x === neighbor.x && c.y === neighbor.y && cZ === nZ;
                    })) {
                        visited.add(key);
                        queue.push(neighbor);
                    }
                }
            }
            
            return visited.size === cells.length;
        }

        function findEmptySpotForShape(cells) {
            // Try to find a spot on the current viewing layer
            const layerZ = is3D ? currentViewLayer : 0;
            
            for (let y = 0; y < boardHeight; y++) {
                for (let x = 0; x < boardWidth; x++) {
                    // Check if all cells of the shape fit here
                    let fits = true;
                    for (const [dx, dy, dz] of cells) {
                        const checkX = x + dx;
                        const checkY = y + dy;
                        const checkZ = layerZ + dz;
                        
                        // Check bounds
                        if (checkX < 0 || checkY < 0 || checkZ < 0 ||
                            checkX >= boardWidth || checkY >= boardHeight || checkZ >= boardDepth) {
                            fits = false;
                            break;
                        }
                        
                        // Check if occupied
                        if (isPieceAt(checkX, checkY, checkZ)) {
                            fits = false;
                            break;
                        }
                    }
                    
                    if (fits) {
                        return {x, y, z: layerZ};
                    }
                }
            }
            
            return null;
        }

        // Debug compound moves
        function debugCompoundMoves() {
            if (!currentGraph || currentGraph.getStateCount() === 0) {
                alert('No graph generated yet. Generate a graph first.');
                return;
            }
            
            console.log('=== DEBUGGING COMPOUND MOVES ===');
            
            // Test compound moves on the first state
            const firstState = currentGraph.getStateById(0);
            console.log('Testing compound moves on first state:', firstState);
            
            const compoundMoves = firstState.generateCompoundMoves();
            console.log(`Found ${compoundMoves.length} compound moves (after filtering redundant ones):`);
            
            // Also show single moves for comparison
            const singleMoves = firstState.getSingleMoves();
            console.log(`Found ${singleMoves.length} single moves:`);
            
            compoundMoves.forEach((move, i) => {
                console.log(`  Compound Move ${i + 1}:`, {
                    type: move.type,
                    pieces: move.pieces,
                    direction: move.direction,
                    fromPositions: move.fromPositions,
                    toPositions: move.toPositions
                });
            });
            
            // Test dependency graph for each direction
            const directions = firstState.is3D ? 
                [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]] :
                [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0]];
            
            console.log('\n=== DEPENDENCY GRAPHS ===');
            directions.forEach((dir, i) => {
                const deps = firstState.buildDependencyGraph(dir);
                console.log(`Direction ${i + 1} [${dir.join(',')}]:`, deps);
                
                const sccs = firstState.findStronglyConnectedComponents(deps);
                console.log(`  SCCs:`, sccs);
                
                // Show which pieces are truly interlocked
                sccs.forEach((scc, sccIndex) => {
                    if (scc.length > 1) {
                        console.log(`    SCC ${sccIndex}: Pieces ${scc.join(', ')} are interlocked`);
                        
                        // Check if they're truly interlocked (can't move individually)
                        let allBlocked = true;
                        for (const pieceId of scc) {
                            const block = firstState.blocks.find(b => b.id === pieceId);
                            const blockZ = block.z || 0;
                            const newX = block.x + dir[0];
                            const newY = block.y + dir[1];
                            const newZ = blockZ + dir[2];
                            
                            if (firstState.canMove(pieceId, newX, newY, newZ)) {
                                console.log(`      Piece ${pieceId} CAN move individually - not truly interlocked`);
                                allBlocked = false;
                            }
                        }
                        if (allBlocked) {
                            console.log(`      All pieces in SCC ${sccIndex} are truly blocked`);
                        }
                    }
                });
            });
            
            // Show results in UI
            const results = document.createElement('div');
            results.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a2e;
                border: 2px solid #4488ff;
                border-radius: 10px;
                padding: 20px;
                max-width: 80vw;
                max-height: 80vh;
                overflow-y: auto;
                z-index: 1000;
                color: white;
                font-family: monospace;
                font-size: 12px;
            `;
            
            results.innerHTML = `
                <h3 style="margin-top: 0; color: #4488ff;">Compound Moves Debug</h3>
                <p><strong>Single moves:</strong> ${singleMoves.length}</p>
                <p><strong>Compound moves (after filtering):</strong> ${compoundMoves.length}</p>
                <p style="font-size: 10px; color: #aaa;">Compound moves are filtered to only include those that reach states not achievable by single moves.</p>
                <div style="max-height: 300px; overflow-y: auto;">
                    ${compoundMoves.map((move, i) => `
                        <div style="margin: 10px 0; padding: 10px; background: #2a2a3e; border-radius: 5px;">
                            <strong>Compound Move ${i + 1}:</strong><br>
                            <strong>Pieces:</strong> ${move.pieces.join(', ')}<br>
                            <strong>Direction:</strong> [${move.direction.join(', ')}]<br>
                            <strong>From:</strong> ${move.fromPositions.map(p => `(${p.x},${p.y}${firstState.is3D ? `,${p.z}` : ''})`).join(', ')}<br>
                            <strong>To:</strong> ${move.toPositions.map(p => `(${p.x},${p.y}${firstState.is3D ? `,${p.z}` : ''})`).join(', ')}
                        </div>
                    `).join('')}
                </div>
                <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 8px 16px; background: #4488ff; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
            `;
            
            document.body.appendChild(results);
        }

        // Graph Export/Import Functions
        function exportGraphForCUDA() {
            if (!currentGraph || !visualizer) {
                console.log('No graph generated yet');
                return;
            }
            
            const nodeCount = currentGraph.getStateCount();
            const treatShapesAsUnique = currentGraph.treatShapesAsUnique || false;
            
            // Get current state data
            const states = [];
            for (let i = 0; i < nodeCount; i++) {
                const state = currentGraph.getStateById(i);
                states.push({
                    id: i,
                    blocks: state.blocks,
                    width: state.width,
                    height: state.height,
                    depth: state.depth || 1,
                    is3D: state.is3D || false,
                    hash: state.getHash(treatShapesAsUnique),
                    isWinning: state.isWinning()
                });
            }
            
            // Get edges
            const edges = currentGraph.edges.map(edge => ({
                from: edge.from,
                to: edge.to,
                moveId: edge.moveId
            }));
            
            // Get current positions from visualizer
            const positions = [];
            for (let i = 0; i < nodeCount * 3; i++) {
                positions.push(visualizer.positions[i]);
            }
            
            // Export as JSON with current layout
            const exportData = {
                states: states,
                edges: edges,
                positions: positions,
                layout_params: layoutParams,
                treatShapesAsUnique: treatShapesAsUnique,
                metadata: {
                    node_count: nodeCount,
                    edge_count: currentGraph.edges.length,
                    exported_at: new Date().toISOString(),
                    version: '1.1'
                }
            };
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'klotski_graph_layout.json';
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('Exported graph with layout:', nodeCount, 'nodes,', currentGraph.edges.length, 'edges');
        }

        function importCUDALayout() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Check if this is a full graph with layout
                        if (data.states && data.edges && data.positions) {
                            console.log('Importing complete graph with layout...');
                            
                            // Recreate the graph from the imported data
                            const states = data.states.map(stateData => {
                                return new KlotskiState(
                                    stateData.blocks, 
                                    stateData.width || 4, 
                                    stateData.height || 5,
                                    stateData.depth || 1
                                );
                            });
                            
                            const importedGraph = new StateSpaceGraph();
                            importedGraph.stateList = states;
                            
                            // Set the treatShapesAsUnique parameter from imported data
                            const treatShapesAsUnique = data.treatShapesAsUnique || false;
                            importedGraph.treatShapesAsUnique = treatShapesAsUnique;
                            
                            // Update the checkbox to match the imported setting
                            document.getElementById('uniqueShapesCheckbox').checked = treatShapesAsUnique;
                            
                            // Rebuild the states map with state objects using correct hash method
                            for (let i = 0; i < states.length; i++) {
                                const state = states[i];
                                const hash = state.getHash(treatShapesAsUnique);
                                importedGraph.states.set(hash, {
                                    state: state,
                                    id: i,
                                    neighbors: []
                                });
                            }
                            
                            // Rebuild edges and neighbor lists
                            importedGraph.edges = data.edges;
                            
                            for (const edge of data.edges) {
                                const fromState = states[edge.from];
                                const toState = states[edge.to];
                                const fromHash = fromState.getHash(treatShapesAsUnique);
                                const toHash = toState.getHash(treatShapesAsUnique);
                                
                                const fromData = importedGraph.states.get(fromHash);
                                const toData = importedGraph.states.get(toHash);
                                
                                if (fromData && !fromData.neighbors.includes(edge.to)) {
                                    fromData.neighbors.push(edge.to);
                                }
                                
                                if (toData && !toData.neighbors.includes(edge.from)) {
                                    toData.neighbors.push(edge.from);
                                }
                            }
                            
                            // Set as current graph
                            currentGraph = importedGraph;
                            
                            // Apply layout params if available
                            if (data.layout_params) {
                                Object.assign(layoutParams, data.layout_params);
                                console.log('Applied imported layout parameters');
                            }
                            
                            // Visualize with imported positions
                            visualizer.visualizeGraph(currentGraph, 'custom', new Float32Array(data.positions));
                            
                            // Verify import
                            console.log('Graph with layout imported successfully!');
                            console.log(`  States: ${currentGraph.stateList.length}`);
                            console.log(`  Edges: ${currentGraph.edges.length}`);
                            console.log(`  States map size: ${currentGraph.states.size}`);
                            
                            // Verify first state has correct structure
                            if (currentGraph.stateList.length > 0) {
                                const firstState = currentGraph.stateList[0];
                                const firstHash = firstState.getHash();
                                const firstData = currentGraph.states.get(firstHash);
                                console.log(`  First state check:`, {
                                    hasState: !!firstData?.state,
                                    hasNeighbors: Array.isArray(firstData?.neighbors),
                                    neighborCount: firstData?.neighbors?.length || 0,
                                    is3D: firstState.is3D
                                });
                            }
                            
                        } else if (data.positions) {
                            // Legacy format - just positions
                            if (!currentGraph) {
                                console.error('No graph loaded to apply positions to');
                                return;
                            }
                            
                            let positions;
                            if (data.num_nodes) {
                                // CUDA format
                                positions = new Float32Array(data.num_nodes * 3);
                                for (let i = 0; i < data.num_nodes; i++) {
                                    positions[i * 3] = data.positions[i * 3];
                                    positions[i * 3 + 1] = data.positions[i * 3 + 1];
                                    positions[i * 3 + 2] = data.positions[i * 3 + 2];
                                }
                            } else {
                                // Direct positions array
                                positions = new Float32Array(data.positions);
                            }
                            
                            // Apply to visualizer
                            visualizer.positions = positions;
                            visualizer.updateNodePositions();
                            
                            console.log('Layout positions imported successfully!');
                        } else {
                            console.error('Invalid layout data format');
                        }
                    } catch (error) {
                        console.error('Error importing graph layout:', error);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Event listeners
        document.getElementById('generateBtn').addEventListener('click', generateGraph);
        document.getElementById('editBoardBtn').addEventListener('click', openEditor);
        document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);
        document.getElementById('exportCudaBtn').addEventListener('click', exportGraphForCUDA);
        document.getElementById('importCudaBtn').addEventListener('click', importCUDALayout);
        document.getElementById('applyParamsBtn').addEventListener('click', applyParameters);
        document.getElementById('resetParamsBtn').addEventListener('click', () => {
            resetParameters();
            applyParameters();
        });
        document.getElementById('showNodesToggle').addEventListener('change', (e) => {
            visualizer.setShowAllNodes(e.target.checked);
        });
        

        setupSliders();

        // Load saved graph on startup
        async function loadSavedGraph() {
            const loadingElement = document.getElementById('loading');
            const loadingMessage = document.getElementById('loadingMessage');
            
            try {
                // Show loading with appropriate message
                loadingMessage.textContent = 'Loading saved graph...';
                loadingElement.classList.remove('hidden');
                
                const response = await fetch('klotski_graph_layout.json');
                if (!response.ok) {
                    console.log('No saved graph found, opening editor');
                    loadingElement.classList.add('hidden');
                    openEditor();
                    return;
                }
                
                const data = await response.json();
                console.log('Loading saved graph layout...');
                
                // Recreate the graph from the saved data
                const states = data.states.map(stateData => {
                    return new KlotskiState(
                        stateData.blocks, 
                        stateData.width || 4, 
                        stateData.height || 5,
                        stateData.depth || 1
                    );
                });
                
                const importedGraph = new StateSpaceGraph();
                importedGraph.stateList = states;
                
                // Rebuild the states map with state objects
                for (let i = 0; i < states.length; i++) {
                    const state = states[i];
                    const hash = state.getHash();
                    importedGraph.states.set(hash, {
                        state: state,
                        id: i,
                        neighbors: []
                    });
                }
                
                // Rebuild edges and neighbor lists
                importedGraph.edges = data.edges;
                
                for (const edge of data.edges) {
                    const fromState = states[edge.from];
                    const toState = states[edge.to];
                    const fromHash = fromState.getHash();
                    const toHash = toState.getHash();
                    
                    const fromData = importedGraph.states.get(fromHash);
                    const toData = importedGraph.states.get(toHash);
                    
                    if (fromData && !fromData.neighbors.includes(edge.to)) {
                        fromData.neighbors.push(edge.to);
                    }
                    
                    if (toData && !toData.neighbors.includes(edge.from)) {
                        toData.neighbors.push(edge.from);
                    }
                }
                
                // Set as current graph
                currentGraph = importedGraph;
                
                // Apply layout params if available
                if (data.layout_params) {
                    Object.assign(layoutParams, data.layout_params);
                    console.log('Applied saved layout parameters');
                }
                
                // Visualize with saved positions
                visualizer.visualizeGraph(currentGraph, 'custom', new Float32Array(data.positions));
                
                console.log('Saved graph loaded successfully!');
                console.log(`  States: ${currentGraph.stateList.length}`);
                console.log(`  Edges: ${currentGraph.edges.length}`);
                
                // Hide loading indicator
                loadingElement.classList.add('hidden');
                
            } catch (error) {
                console.error('Error loading saved graph:', error);
                console.log('Opening editor instead');
                loadingElement.classList.add('hidden');
                openEditor();
            }
        }

        // Start the application
        window.addEventListener('load', () => {
            init();
            loadSavedGraph();
        });
    </script>
</body>
</html>

